#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
# Utility to create a default configuration from csv-data.
#
# The program reads the first line of data from a file. It then creates a
# default configuration for the data. If the first line contains
# non-numeric data, this is considered as a header line and the values
# are used for the data-labels.
#
# Note: you really have to edit the result! If you e.g. don't remove
# non-numeric columns from the configuration, the plot will fail.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/py-datamon
#
# ----------------------------------------------------------------------------

import locale, time, os, sys, json, csv
from   argparse import ArgumentParser

# --- application imports   --------------------------------------------------

libdir = os.path.join(os.path.dirname(sys.argv[0]),"..","lib","py-datamon")
sys.path.append(str(libdir))

# --- application class   ----------------------------------------------------

class App:

  # --- constructor   --------------------------------------------------------

  def __init__(self):
    """ constructor """

    self.debug       = False
    parser = self._get_parser()
    parser.parse_args(namespace=self)

  # --- cmdline-parser   -----------------------------------------------------

  def _get_parser(self):
    """ configure cmdline-parser """

    parser = ArgumentParser(add_help=False,description='Python Datamonitor')

    parser.add_argument('-c', '--config', metavar='conf',
      help='name of config-file to create')

    parser.add_argument('-d', '--debug', action='store_true',
      dest='debug', default=False,
      help="force debug-mode")
    parser.add_argument('-q', '--quiet', action='store_true',
      dest='quiet', default=False,
      help="don't print messages")
    parser.add_argument('-h', '--help', action='help',
      help='print this help')

    parser.add_argument('input', metavar='input',help='input-file')

    return parser

  # --- get delimiter of csv-data   ------------------------------------------

  def _get_delim(self,file=None,line=None):
    """ guess delimiter by sniffing the given line """

    if file is None:
      return csv.Sniffer().sniff(line).delimiter,line
    else:
      with open(file,'rt') as csvfile:
        line = csvfile.readline().rstrip('\n')
        return self._get_delim(line=line)

  # --- guess if words contain data or a header   ----------------------------

  def _check_header(self,words):
    """ check for csv-header: assume that no field is numeric """

    for word in words:
      try:
        float(word)          # if this does not trigger a ValueError
        return False         # we have a dataline and no header
      except ValueError:
        pass                 # check next word
    return True              # no numeric field, so assume header

  # --- read data   ----------------------------------------------------------

  def read(self):
    """ read data from csv/stdin """

    if self.input == "-":
      self.input = "/dev/stdin"

    delim,line = self._get_delim(file=self.input)
    words      = line.split(delim)[1:]
    self.msg("App: delimiter is '%s'" % delim)

    self._n = len(words)
    if self._check_header(words):
      self._labels = words
    else:
      self._labels = ["column %d" % c for c in range(1,self._n+1)]
    self.msg("App: labels: %r" % (self._labels,))

  # --- create config-file   -------------------------------------------------

  def create_config(self):
    """ create configuration """

    # configure one plot for every value
    plots = []
    for i,label in enumerate(self._labels):
      cfg = {
        "title": label,
        "values": [{"col": i+1,"label": label}]
        }
      plots.append(cfg)

    # create top-level config
    self._conf = {
      "title":  "Autogenerated Configuration",
      "cols":   min(int((self._n-1)/3)+1,3),
      "x":      {"col": 0},
      "legend": {"loc": None},
      "plots":  plots
      }

  # --- save config-file   ---------------------------------------------------

  def save_config(self):
    """ save configuration """

    f = open(self.config,"w")
    self.msg("App: Saving configuration to %s" % self.config,True)
    json.dump(self._conf,f,indent=2)
    f.close()

  # --- print message   ------------------------------------------------------

  def msg(self,text,force=False):
    """ print message """

    if force:
      sys.stderr.write("%s\n" % text)
    elif self.debug:
      sys.stderr.write("[DEBUG %s] %s\n" % (time.strftime("%H:%M:%S"),text))
    sys.stderr.flush()

# --- main program   ---------------------------------------------------------

if __name__ == '__main__':

  # set local to default from environment
  locale.setlocale(locale.LC_ALL, '')

  # create application-class, read configuration
  app = App()
  app.read()
  app.create_config()
  app.save_config()

